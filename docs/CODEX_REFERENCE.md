# Codex Agent Instructions

You are continuing backend development work handed off from Claude (clb). Follow these instructions to maintain consistency and proper handoff protocol.

## Startup Checklist

**Every time you start, do this first:**

1. Read `.lovable/HANDOFF.md` for context from Claude
2. Read `.lovable/TASKS.md` for full task list
3. Understand what was done and what's next
4. Then continue from where Claude left off

```bash
cat .lovable/HANDOFF.md
cat .lovable/TASKS.md
```

## Core Responsibilities

1. **Continue backend work** from Claude's handoff
2. **Document ALL work** in `.lovable/TASKS.md`
3. **Update HANDOFF.md** when stopping (for next session)
4. **Signal frontend** when backend tasks complete
5. **Follow the same patterns** Claude established

## Project Structure

```
firm-schedule-assistant/
├── src/                    # Frontend (React + Vite + TypeScript)
│   ├── components/         # UI components
│   ├── pages/              # Route components
│   └── lib/                # Shared utilities (read-only)
├── supabase/
│   ├── functions/          # Backend Edge Functions (Deno)
│   ├── migrations/         # Database schema
│   └── config.toml
├── openapi.yaml            # API contract (source of truth)
├── .lovable/               # Handoff state files
│   ├── TASKS.md            # Project task list
│   ├── HANDOFF.md          # Continuation context
│   └── FRONTEND_SIGNAL.md  # Backend ready signal
└── docs/                   # Documentation
```

## File Ownership

| Domain | Your Territory | Stay Away |
|--------|---------------|-----------|
| Backend | `supabase/**`, `openapi.yaml` | `src/components/**`, `src/pages/**` |

You own backend. Don't touch frontend components or pages.

## Git Sync Protocol

**Before starting a major feature or task cluster:**
1. Run `git pull` to sync with remote
2. If conflicts exist, notify user before proceeding
3. Announce: "Pulled latest changes before starting [feature]"

**When to pull:**
- Starting a new feature
- Beginning a group of related endpoints
- User requests significant work
- NOT needed for small fixes

**After completing a task cluster:**
1. Summarize what was completed
2. Ask: "These tasks are complete. Ready to push to GitHub?"
3. If yes: `git add . && git commit -m "[summary]" && git push`
4. If no: Continue to next tasks

## Task Documentation Protocol

**ALWAYS update `.lovable/TASKS.md` after completing ANY work.**

Format:
```markdown
# TASKS.md

## Project: [Project Name]
Last Updated: [ISO timestamp]
Updated By: codex

## Completed Tasks
- [x] 2026-01-19 | Task description | codex

## In Progress
- [ ] Current task | Started by: codex

## Pending Tasks
- [ ] Future task

## Frontend Ready
<!-- Features ready for UI implementation -->

## Notes
<!-- Important context or decisions -->
```

**Update frequency:** After EVERY completed task, not in batches.

## Handoff Protocol

### Reading Handoff (from Claude)

Claude creates `.lovable/HANDOFF.md` before stopping. Read it to understand:
- What was being worked on
- Where Claude stopped
- What to do next
- Key files to review

### Writing Handoff (when you stop)

When stopping mid-task, update `.lovable/HANDOFF.md`:

```markdown
# Handoff

Updated: [ISO timestamp]
From: codex
Status: in-progress | ready-for-ui | blocked

## Current State
- Working on: [feature/task]
- Last completed: [specific task]
- Next step: [specific action to take]

## Context
[2-3 paragraphs explaining:
- What you were implementing
- The approach being taken
- Any decisions made
- Current state of the work]

## Files to Review
- [list key files the next session should read]

## Notes
[Gotchas, blockers, incomplete implementations, design decisions]
```

**Important:** Overwrite the file with current context. Don't append - the next session only needs current state.

## Frontend Signal Protocol

When backend tasks are **ready for UI implementation**, create `.lovable/FRONTEND_SIGNAL.md`:

```markdown
# Frontend Signal

Generated: [ISO timestamp]
Status: READY_FOR_UI
Generated By: codex

## Completed Backend Work
- [x] Feature 1
- [x] Feature 2

## UI Changes Needed
1. Component 1 - description
2. Component 2 - description

## API Contracts
[Document the endpoints and their request/response shapes]
```

## Code Quality Standards

1. **No `any` types** - Always define proper types
2. **Error handling** - Try/catch with meaningful error messages
3. **Async/await** - No raw promises or callbacks
4. **Consistent naming** - camelCase for variables, PascalCase for types
5. **Single responsibility** - Functions do one thing well
6. **Comments for why, not what** - Code should be self-documenting

## Bulletproof-React Principles

Follow the same patterns Claude uses:

**Feature-based structure:**
```
src/features/
  auth/
    api/          # API calls
    components/   # Feature components
    hooks/        # Feature hooks
    types/        # TypeScript types
    index.ts      # Public API
```

**Key principles:**
- Separation of concerns - features are self-contained
- Colocation - keep related code together
- Explicit exports - use index.ts for public API
- Type safety - TypeScript everywhere

## Build & Test Commands

```bash
npm run build              # Build frontend
npm run lint               # Lint check
supabase functions serve   # Local backend
supabase db reset          # Reset local DB
supabase functions deploy  # Deploy functions
```

## API Contract

The `openapi.yaml` file is the source of truth.

- **Always update** `openapi.yaml` when adding/changing endpoints
- Frontend relies on this contract

## Workflow Example

```
1. Start session
   └── Read HANDOFF.md and TASKS.md
   └── "Continuing from: [task from handoff]"

2. Before major feature
   └── git pull
   └── "Pulled latest before starting [feature]"

3. Work on tasks
   └── Implement features
   └── Update TASKS.md after each completion
   └── Update openapi.yaml for API changes

4. Task cluster complete
   └── "Completed: [list tasks]"
   └── "Ready to push to GitHub?"
   └── If yes: commit and push

5. Stopping mid-task
   └── Update HANDOFF.md with current context
   └── "Handoff updated. Next session can continue from [point]"

6. Backend ready for UI
   └── Create FRONTEND_SIGNAL.md
   └── "Frontend signal created. UI work can proceed."
```

## Important Reminders

1. **Read handoff first** - Always start by reading HANDOFF.md
2. **Git pull before major features** - Sync before big work
3. **Ask to push after task clusters** - Prompt user when feature complete
4. **Document as you go** - Update TASKS.md after EVERY task
5. **Update handoff when stopping** - Don't leave context behind
6. **Signal frontend** - They can't work until you tell them backend is ready
7. **Type everything** - TypeScript is non-negotiable
8. **Keep it simple** - Solve today's problems, don't over-engineer
